
/*
 * class DJSParserSemantics
 *
 * This class arbitrates the rules of insertion when Dominate attempts to
 * add content captured from document.write
 */

    var DJSParserSemantics = {};

/*
 * DJSParserSemantics.insertionRules
 * 
 * These rules govern the insertion of elements into other elements in the
 * context of the DOM.
 * 
 * Based on HTML5 semantics: 
 * http://dev.w3.org/html5/spec/Overview.html
 */
    DJSParserSemantics.elementSemantics = {
        'head': {
            inclusive: {
                'html': 1
            }
         },
        'title': {
            inclusive: {
                'head': 1
            }
        },
        'base': {
            inclusive: {
                'head': 1
            }
        },
        'link': {
            exclusive: { }
        },
        'meta': {
            exclusive: { }
        },
        'style': {
            exclusive: { }
        },
        'script': {
            exclusive: { }
        },
        'noscript': {
            exclusive: {
                'noscript': 1
            } //TODO: noscript cannot be a descendant of noscript, even indirectly
        },
        'body': {
            inclusive: {
                'html': 1
            }
        },
        'div': { // this is a hack until proper flow / phrasing classes are used
            exclusive: {
                'p': 1
            }
        }
        // TODO: define rules in terms of content models (tag classes), i.e. flow content vs phrasing content
    };

/*
 * DJSParserSemantics.isValidParent
 *
 * This helper function returns true if node can be inserted into parentNode
 * according to HTML5 semantic rules.
 */
    DJSParserSemantics.isValidParent = function(node, parentNode) {

        var rules = DJSParserSemantics.elementSemantics,
            nodeName = node.nodeName.toLowerCase(),
            parentNodeName = parentNode.nodeName.toLowerCase();

        if (!rules[nodeName]) {
            return true;
        }

        if (rules[nodeName].inclusive) {
            return !!rules[nodeName].inclusive[parentNodeName];
        } else if (rules[nodeName].exclusive) {
            return !rules[nodeName].exclusive[parentNodeName];
        }

        return !(rules[nodeName]) ||
            (rules[nodeName].inclusive && !!rules[nodeName].inclusive[parentNodeName]) || 
            (rules[nodeName].exclusive && !rules[nodeName].exclusive[parentNodeName]);
    };


    DJSParserSemantics.mixins = {

/*
 * DJSParserSemantics.mixins.convertAbstractElement
 *
 * Given abstract data for an element as generated by the HTML parser, this
 * method will return a DOM element. This method is 
 */
         convertAbstractElement: function(abstractElement) {
            
            var self = this,
                document = self.document,
                setNodeAttributes = function(node, attributes) {
                    
                    if(attributes) {
                        DJSUtil.forEach(
                            attributes,
                            function(value, key) {

                                switch(key) {

                                    case 'class':
                                        node.className += value;
                                        break;
                                    default:
                                        DJSUtil.setAttribute.call(node, key, value);
                                        break;
                                }
                            }
                        );
                    }
                };
                
            switch(abstractElement.type) {
                
                case 'text':
                    
                    return document.createTextNode(abstractElement.data);

                case 'comment':
                    
                    return document.createComment(abstractElement.data);

                case 'script':
                    
                    var script = document.createElement(abstractElement.name);
                    
                    setNodeAttributes(script, abstractElement.attribs);

                    return script;

                case 'style':
                case 'tag':
                    
                    var node = document.createElement(abstractElement.name);
                    
                    setNodeAttributes(node, abstractElement.attribs);
                    
                    return node;

                case 'directive':
                    DJSUtil.log('Ignoring an HTML directive found in document.write stream ' + abstractElement.raw);
                    return false;

                default: 
                    DJSUtil.error('WARNING: unexpected element type found: ' + abstractElement.raw);
                    return false;
            }
        },

/*
 * DJSParserSemantics.mixins.insert
 *
 * Given abstract DOM data as generated by the HTML parser, and optionally a
 * parent node, this method will iterate over the data and ensure that it is
 * properly inserted into the DOM.
 *
 * In all browsers in Standards mode, tags inserted with document.write
 * cannot bring the DOM into an invalid structure (i.e. <p><div></div></p>).
 * So, the browser will close open tags until a valid structure is reached
 * (i.e. <p></p><div></div>).  To simulate this behavior, inserted nodes
 * can "bubble" up the dom until a vaild structure is found.  Bubble events
 * will permanently adjust the insertion cursor until a new script.
 */
        insert: function(abstractDOM, rawParent) {
             
            // Implementation notes:
            //
            // Basically we are performing a depth-first traversal
            // of the tag tree given as abstractDOM, with one enhancement:
            // Closed Nodes.
            //
            // For any node, we may encounter an Invalid Insertion, such
            // as insert(<div>, <p>) or insert(<div>) when the stream cursor
            // is a <p> tag.  In this situation, we move up the tree until we
            // find a valid parent.  All candidate parents tried along the way
            // are marked Closed.
            //
            // Insert must not insert any nodes into a Closed Node.
            // insert(nodeA, nodeB) where nodeB is Closed will attach
            // nodeA to nodeB's most immediate non-Closed parent.
            //
            // Closedness is a property of HTML Elements which must persist
            // after this function completes.
            var self = this,
                document = self.document;

            DJSUtil.forEach(
                abstractDOM,
                function(data) {

                    // Return the streamCursor for the current document, 
                    // or the most immediate non-Closed parent
                    // in the event that the streamCursor is closed.
                    var getEffectiveStreamCursor = function() {

                        // Search begins at the first defined insertion point:
                        // 1 parent (for recursive group insertion)
                        // 2 streamCursor.executingScript.parentNode
                        // (if script parent was not know)
                        // 3 document.body (if script did not attach
                        // successfully)
                        var rawCursor = {

                            parent: null,
                            sibling: null
                        };

                        if (rawParent) {

                            rawCursor.parent = rawParent;

                        } else if (self.streamCursor.executingScript) {

                            rawCursor.parent = self.streamCursor.executingScript.parentNode;

                            rawCursor.sibling = self.streamCursor.executingScript;

                        } else {

                            rawCursor.parent = document.body;

                        }

                        return (function getFirstNonClosedParent(cursor) {

                            var finalCursor;

                            if (!cursor.parent.closed) {

                                // Current cursor is fine
                                finalCursor = cursor;

                            } else if (cursor.parent.parentNode) {

                                // Climb up the tree
                                finalCursor = getFirstNonClosedParent({

                                    parent: cursor.parent.parentNode,

                                    sibling: cursor.parent
                                });

                            } else {
                                
                                // Fallback: use document.body if
                                // everything is closed
                                finalCursor = {

                                    parent: document.body,

                                    sibling: null
                                };
                            }

                            return finalCursor;

                        })(rawCursor);
                    };

                    // Find the ancestor of 'cursor' for which 'node' is a 
                    // valid child, i.e. <div> cannot be a child of <p>.  
                    // Search begins with 'cursor'.
                    //
                    // Closes all invalid nodes encountered during the
                    // search.
                    var findValidAncestorAndCloseNodes = function(node, cursor) {

                        var parent = cursor.parent;

                        if (DJSParserSemantics.isValidParent(node, parent)) {

                            return cursor;

                        } else {

                            parent.closed = true;

                            if (parent.parentNode) {

                                return findValidAncestorAndCloseNodes(node, {
                                    parent: parent.parentNode,
                                    sibling: parent
                                });

                            } else {

                                return document.body;

                            }
                        }
                    };

                    var cursor = getEffectiveStreamCursor(),
                        node = self.convertAbstractElement(data),
                        name = node.nodeName.toLowerCase();

                    
                    // Cursor will be either
                    // > the parent node in the the insertion group
                    // > the parent node of document.write's callee script node
                    // > the nearest non-closed parent node of one of the above
                    try {

                        if (cursor.parent.nodeName.toLowerCase() == "script" && name == "#text") {

                            cursor.parent.text = node.nodeValue;

                        } else {

                            var parent, sibling;

                            cursor = findValidAncestorAndCloseNodes(node, cursor);

                            parent = cursor.parent, sibling = cursor.sibling;

                            if (sibling) {

                                parent.insertBefore(node, sibling);

                            } else {

                                parent.appendChild(node);
                            }
                        }

                        if (data.children) {

                            self.insert(data.children, node);
                        }

                    } catch(e) {

                        DJSUtil.log('Insert failed');
                        DJSUtil.error(e);
                    }
                }
            );
        }
    };
