/*
 * class DJSDocument
 *
 * This class wraps the document object. It ensures that all calls to the
 * document's write and writeln properties are handled in a safe way.
 */
    var DJSDocument = function(document) {
        
        var self = this;

        DJSDominatrix.call(self, document);
        
        if(html) {
            self.hasWriteBuffer = false;
            self.parser = new html.Parser(
                new html.DefaultHandler(
                    function(error, dom) {
                        
                        if(error) {
                            
                            DJSUtil.error('PARSER ERROR: ' + error);
                        } else {

                            self.insert(dom);
                        }
                    }
                )
            );
        } else {
        	
        	DJSUtil.error('Warning: no HTML parser detected. Document.write will be disabled!');
        }
    };

    DJSUtil.subclass(
        DJSDominatrix, 
        DJSDocument,
        {

/*
 * DJSDocument.dominate
 *
 * This method replaces the native document.write and document.writeln properties
 * with an asynchronous-load-safe alternative. Additionally, it captures the
 * DOMContentReady event if it is dispatched, and forwards it to any handlers at
 * the appropriate time.
 */
            dominate: function() {

                var self = this,
                    writeWrapper = function(out) {
                        
                        self.write(out);
                    };

                DJSDominatrix.prototype.dominate.apply(this);

                self.wrapNativeMethod("write", writeWrapper);
                self.wrapNativeMethod("writeln", writeWrapper);

                self.wrapNativeMethod("open", function(){
                    DJSUtil.log('Ignoring document.open');
                });
                self.wrapNativeMethod("close", function(){
                    DJSUtil.log('Ignoring document.close');
                });

                self.wrapNativeMethod(
                    "createElement",
                    function(type) {

                        var args = arguments,
                            nativeMethods = self.nativeMethods,
                            element = DJSUtil.feature.createElementCallApply ? nativeMethods.createElement.apply(document, args) : nativeMethods.createElement(type);

                        if(type.indexOf('script') != -1) {

                            slaveScripts.pushSubscript(element);
                        }

                        return element;
                    }
                );

                self.deferEvent("DOMContentLoaded");
                self.deferEvent("readystatechange");
            },

/*
 * DJSDocument.ready
 *
 * When called, this simulates the dispatching of the DOMContentLoaded event
 * and the readystatechange event.
 */
            ready: function() {

                var self = this;
                self.fireEvent("DOMContentLoaded");
                self.fireEvent("readystatechange");
            },

/*
 * DJSDocument.write
 *
 * Let scripts execute document.write post-onload without clobbering the page
 *
 * This method inserts nodes into the DOM given a fragment of HTML. Ideally,
 * a call to DJSDocument.write(html) post-onload and document.write(html)
 * pre-onload would yeild the same DOM structure.
 * 
 * General approach: use an HTML parser and HTML semantics engine to simulate
 * the browser's native behavior.
 *
 * @param out : object - will be cast to a string
 */

            write: function(out) {
                
                var self = this,
                    parser = self.parser;

                out = DJSUtil.getClass(out) == "String" ? out : '' + out;

                DJSUtil.log('Buffering document.write content: ' + out);
                
                if(parser && DJSParserSemantics) {

                    self.hasWriteBuffer = true;
                    DJSParserSemantics.mixins.withParserDocwrite.apply(self, [parser, out]);
                } else {
                    
                    DJSUtil.log('Ignoring document.write content: ' + out);
                    // TODO: Fallback to the span / innerHtml option?
                }
            },

/*
 * DJSDocument.flush
 *
 * Cuts off the current buffer and asks the parser to attempt to parse it.
 */
            flush: function() {
            
                var self = this;
                
                DJSUtil.log('Flushing document.write buffer!');
                
                if(self.hasWriteBuffer) {

                    self.parser.done();
                    self.parser.reset();
                    self.hasWriteBuffer = false;
                }
            },

/*
 * DJSDocument.convertAbstractElement
 *
 * Given abstract data for an element as generated by the HTML parser, this
 * method will return a DOM element.
 * 
 * This method forwards to the DJSParserSemantics mixin if available. Otherwise
 * it does nothing.
 */

            convertAbstractElement: function(abstractElement) {
             
                var self = this;

                // TODO: Look into a more elegant method for incorporating mixins..
                if(DJSParserSemantics) {

                    return DJSParserSemantics.mixins.convertAbstractElement.apply(self, arguments);
                }
            },

/*
 * DJSDocument.insert
 *
 * Inserts parsed document.write content into the DOM. Utilizes the
 * DJSParserSemantics.insertionMixin to do this if it is available, otherwise
 * does nothing.
 * 
 * This method forwards calls to the DJSParserSemantics mixin if available.
 * Otherwise it does nothing.
 */
            insert: function(abstractDOM, rawParent) {
                
                var self = this;
                
                if(DJSParserSemantics) {

                    return DJSParserSemantics.mixins.insert.apply(self, arguments);
                }
            }

        }
    );
